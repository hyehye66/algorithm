# Kadane(카데인) 알고리즘

**Maximum Subarray** 최대 부분합을 효율적으로 푸는 방법

Brute Force는 **O(N²)**이 걸리지만, 카데인 알고리즘을 이용하면 **O(N)**으로 문제를 해결할 수 있다.

**✅ 각각의 최대 부분합은 이전 최대 부분합이 반영된 결과값이다.**



## 🔎Maximum Subarray

배열의 연속하는 부분집합의 합들 중 가장 큰 값을 구하는 문제



### 💡카데인 알고리즘을 이용하여 Maximum Subarray를 풀어보자

✅ **끝나는 원소**를 기준으로 부분배열의 합을 구한다!

ex.  arr = `[-3, 1, -4, 6]`

`0`번째로 끝나는 부분배열을 `E(0)`으로 표기할 때

모든 부분배열을 나열하면

```markdown
E(0) : [{-3}]
E(1) : [{-3, 1}, {1}]
E(2) : [{-3, 1, -4}, {1, -4}, {-4}]
E(3) : [{-3, 1, -4, 6}, {1, -4, 6}, {-4, 6}, {6}]
```

즉, `E(i+1)`은 `E(i)`의 각 원소에 `arr[i+1]`을 첨가한 배열이다.

이와 같은 방법으로 최대 부분합을 구하면,

`i`번째 원소로 끝나는 부분배열의 합들 중 최대인 값을 `M(i)`라고 가정하면,

```markdown
M(0) : -3
M(1) : 1 ((-3+1)과 1 중 최대값)
M(2) : -3
M(3) : 6
```

즉, `M(i+1) = max(M(i) + arr[i+1], arr[i+1])`

### *(i번째 최대 부분집합의 합 + 배열의 (i+1)번째 원소)* 🆚 *배열의 (i+1)번째 원소*, 둘을 비교하여 최대 부분합을 도출한다.



---

관련 알고리즘 문제와 풀이: [백준 10211](https://www.acmicpc.net/problem/10211) & [나의 풀이](https://github.com/hyehye66/algorithm/blob/master/BOJ/10211.md)

참고자료)

https://juneyr.dev/2019-11-21/maximum-subarray