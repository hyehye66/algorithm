**💡아이디어**

결과값이 오름차순이나 내림차순 정렬로 도출하는 것이 아니라서 어려웠다. set을 list로 변환하면 오름차순으로 결과가 나왔다. 그래서 초기화된 배열을 두고, 집합의 길이에 해당하는 index에 요소를 추가하는 방법을 생각했다. 다 추가한 후에 그 배열을 돌며 answer 배열에 없는 값을 저장한다.

[Python]

```python
def solution(s):
    answer = []
    s = s[1:-1]
    
    arr = [set() for _ in range(100001)]   
    result = set()
    temp = ''
    for elm in s:
        if elm == '{':
            temp = ''
        elif elm.isdigit():  # 숫자인지 확인
            temp += elm
        elif elm == ',' and temp:
            result.add(int(temp))
            temp = ''
        elif elm == '}':
            result.add(int(temp))
            arr[len(result)].update(result)
            result = set()
            temp = ''
    
    for i in range(1, 100001):
        for elm in arr[i]:
            if elm not in answer:
                answer.append(elm)
    return answer
```

[JavaScript]

```javascript
function solution(s) {
    let answer = [];
    s = s.slice(1, s.length - 1);
    let arr = new Array(100001);
    for (let i = 0; i < 100001; i++) {
        arr[i] = new Set();
    }
    let result = new Set();
    let temp = '';
    for (const elm of s) {
        if (elm == '{') {
            temp = '';
        } else if (!isNaN(elm) && elm != ' ') {
            temp += elm;
        } else if (elm == ',' && temp) {
            result.add(parseInt(temp));
            temp = '';
        } else if (elm == '}') {
            result.add(parseInt(temp));
            // js에서 set의 크기는 length가 아니라 size다!
            arr[result.size] = new Set([...arr[result.size], ...result]);
            result = new Set();
            temp = '';
        }
    }

    for (let i = 1; i < 100001; i++) {
        if (arr[i].size > 0) {
            arr[i].forEach((elm) => {
                // python에서의 not in 역할은 js에서 includes 함수와 비슷하다.
                if (!answer.includes(elm)) {
                    answer.push(elm);
                }
            });
        }
    }

    return answer;
}

```

