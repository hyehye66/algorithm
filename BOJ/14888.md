# ì—°ì‚°ì ë¼ì›Œë„£ê¸°

1. ì²˜ìŒ í’€ì´

   ```python
   # Python3 : ì‹œê°„ì´ˆê³¼, PyPy3 : í†µê³¼
   import sys
   input = sys.stdin.readline
   N = int(input())
   # í”¼ì—°ì‚°ì ë¦¬ìŠ¤íŠ¸
   arr1 = list(map(int, input().strip().split()))
   # ë§ì…ˆ(+)ì˜ ê°œìˆ˜, ëº„ì…ˆ(-)ì˜ ê°œìˆ˜, ê³±ì…ˆ(Ã—)ì˜ ê°œìˆ˜, ë‚˜ëˆ—ì…ˆ(Ã·)ì˜ ê°œìˆ˜ë¡œ ë”•ì…”ë„ˆë¦¬ ìƒì„±
   operator = dict(zip(['+', '-', '*', '/'], list(map(int, input().strip().split()))))
   # ì—°ì‚°ì ê°œìˆ˜ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
   operator2 = sorted(operator.items(), key=lambda x:x[1], reverse=True)
   
   max_val = -1000000001
   min_val = 1000000001
   
   # ì—°ì‚°ì ë¦¬ìŠ¤íŠ¸ ex. ['+', '+', '*']
   arr2 = []
   for i in range(4):
       for j in range(operator2[i][1]):
           arr2.append(operator2[i][0])
   
   # ìš°ì„ ìˆœìœ„ ì—†ì´ ê³„ì‚°
   def calculate(arr):
       global max_val, min_val
       
       # ì•„ë˜ ì£¼ì„ì²˜ëŸ¼ deepcopy ì¨ì„œ ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ popí•œ í›„ 
       # ë‹¤ìŒë¶€í„° 2 ê°œì”© ìŠ¬ë¼ì´ìŠ¤í•´ì„œ ì²´í¬í•˜ë ¤ê³  í–ˆëŠ”ë° [ì‹œê°„ì´ˆê³¼]
       # new_arr = copy.deepcopy(arr)
       # val = new_arr.pop(0)
       
       # ê·¸ë˜ì„œ deepcopy ì—†ì´ ì²«ë²ˆì§¸ ìš”ì†Œ ë³€ìˆ˜ ì„¤ì • í›„ 2 ê°œì”© ìŠ¬ë¼ì´ìŠ¤í•´ì„œ ì—°ì‚°
       val = arr[0]
       for i in range(N-1):
           temp = arr[2*i+1:2*i+3]
           if temp[0] == '+':
               val += temp[1]
           elif temp[0] == '-':
               val -= temp[1]
           elif temp[0] == '*':
               val *= temp[1]
           elif temp[0] == '/':
               if val < 0:
                   val = (abs(val) // temp[1])*(-1)
               else:
                   val //= temp[1]
                   
       # ìµœëŒ€, ìµœì†Œ ì°¾ê¸°
       if max_val < val:
           max_val = val
       if min_val > val:
           min_val = val
       return
   
   # ì‚¬ìš©í•œ ì—°ì‚°ì ì¸ë±ìŠ¤ë¥¼ ë‹´ì•„ë‘ëŠ” ìŠ¤íƒ
   # ì—°ì‚°ì ì¸ë±ìŠ¤ë¥¼ ë‹´ì•„ë‘¬ì„œ ì–´ë–¤ ì—°ì‚°ìë¥¼ ì¼ëŠ”ì§€ í™•ì¸ í›„ ì•ˆ ì“´ ì—°ì‚°ìë¥¼ ìŠ¤íƒì— ìŒ“ê¸°
   order_arr2 = []
   
   def dfs(start):
       if len(arr1) == 2*N -1:
           calculate(arr1)
           return
   
       for i in range(N-1):
           # ì‚¬ìš©í•  ì—°ì‚°ìì˜ ì¸ë±ìŠ¤ê°€ ìŠ¤íƒì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
           if i not in order_arr2:
               arr1.insert(2*start+1, arr2[i]) # ì‚½ì…í•  ìœ„ì¹˜ì˜ ë§¤ê°œë³€ìˆ˜ì™€ ì‚½ì¼í•  ê°’ì˜ ë§¤ê°œë³€ìˆ˜ ë‹¬ë¼ì•¼ í•¨
               order_arr2.append(i)            # ì‚¬ìš©í•œ ì—°ì‚°ìì˜ ì¸ë±ìŠ¤ë¥¼ ìŠ¤íƒì— ë‹´ê¸°
               dfs(start+1)                    # ë‹¤ìŒ ìœ„ì¹˜ì— ì‚½ì…í•  ì—°ì‚°ìë¥¼ ì°¾ì•„ì„œ~
               arr1.pop(2*start+1)             # ì‹(arr1)ì— ë„£ì—ˆë˜ ì—°ì‚°ìë¥¼ ì œê±°
               order_arr2.remove(i)            # ì‚¬ìš©í•œ ì—°ì‚°ì ì¸ë±ìŠ¤ë¥¼ ëª¨ì•„ë‘” ìŠ¤íƒì—ì„œë„ ì œê±°  
   
   dfs(0)
   print(max_val)
   print(min_val)
   ```
   
   
   
2. ì°¸ê³ í•œ í’€ì´

   ğŸ’¡ ì•„ì´ë””ì–´

   ```markdown
   dfsë¥¼ ì´ìš©í•˜ì—¬ ì—°ì‚°ìì˜ ê°œìˆ˜ë§Œí¼ íƒìƒ‰ì„ í•˜ê³ , ì—°ì‚°ìê°€ ì¡´ì¬í•˜ë©´ ê·¸ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë©° ì¬ê·€í˜¸ì¶œì„ í†µí•´ íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.
   ```
   
   âœï¸ í’€ì´
   
   *ì—°ì‚°ìë¥¼ ë‹¤ì‹œ ì •ë ¬í•  í•„ìš”ë„ ì—†ê³  ê¹”ë”í•˜ë‹¤...!*
   
   ```python
   # Python3 í†µê³¼
   import sys
   input = sys.stdin.readline
   N = int(input())
   num = list(map(int, input().split()))
   op = list(map(int, input().split()))  # +, -, *, //
   
   # 1)
   # maximum = -1e9
   # minimum = 1e9
   
   # 2) -1e9-1, 1e9+1 ì´ìƒìœ¼ë¡œ ë‘¬ì•¼ í•¨. -1e9, 1e9ë¡œ ë‘ë©´ í‹€ë¦¼
   maximum = -1e10
   minimum = 1e10
   
   def dfs(depth, total, plus, minus, multiply, divide):
       global maximum, minimum
       if depth == N:
           # 1)
           # maximum = max(total, maximum)
           # minimum = min(total, minimum)
           # return
   
           # 2)
           if total > maximum:
               maximum = total
           if total < minimum:
               minimum = total
           return
   
   
       if plus:
           dfs(depth + 1, total + num[depth], plus - 1, minus, multiply, divide)
       if minus:
           dfs(depth + 1, total - num[depth], plus, minus - 1, multiply, divide)
       if multiply:
           dfs(depth + 1, total * num[depth], plus, minus, multiply - 1, divide)
       if divide:
           dfs(depth + 1, int(total / num[depth]), plus, minus, multiply, divide - 1)
   
   
   dfs(1, num[0], op[0], op[1], op[2], op[3])
   print(maximum)
   print(minimum)
   ```
   

